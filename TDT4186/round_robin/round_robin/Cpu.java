package round_robin;

import java.util.LinkedList;

/**
 * This class implements functionality associated with
 * the CPU unit of the simulated system.
 */
public class Cpu {
	Process activeProcess;
	LinkedList<Process> cpuQueue;
	long maxCpuTime;
	Statistics statistics;
	
    /**
     * Creates a new CPU with the given parameters.
     * @param cpuQueue		The CPU queue to be used.
     * @param maxCpuTime	The Round Robin time quant to be used.
     * @param statistics	A reference to the statistics collector.
     */
    public Cpu(LinkedList<Process> cpuQueue, long maxCpuTime, Statistics statistics) {
        // Incomplete
    	this.cpuQueue = cpuQueue;
    	this.maxCpuTime = maxCpuTime;
    	this.statistics = statistics;
    	
    }
    
    private void updateMaxCpuTime() {
    	Long totalCpuTimeNeeded = cpuQueue.stream().mapToLong(i -> i.getCpuTimeNeeded()).sum();
    	if (cpuQueue.size()>0) this.maxCpuTime = (totalCpuTimeNeeded / (cpuQueue.size())) + 500;
    }
    
    // Avhengig av hva som er kortest tid til vil ulike ting måtte bli lagt til i Event-køen.
    private Event findNextEvent(Process p, long clock) {
    	if (p.getCpuTimeNeeded() <=p.getTimeToNextIo() && p.getCpuTimeNeeded() <= this.maxCpuTime) {
    		return new Event(Event.END_PROCESS, clock + p.getCpuTimeNeeded());
    	} else if (p.getTimeToNextIo() <= this.maxCpuTime) {
    		return new Event(Event.IO_REQUEST, clock + p.getTimeToNextIo());
    	} else {
    		return new Event(Event.SWITCH_PROCESS, clock + this.maxCpuTime);
    	}
    }

    /**
     * Adds a process to the CPU queue, and activates (switches in) the first process
     * in the CPU queue if the CPU is idle.
     * @param p		The process to be added to the CPU queue.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event insertProcess(Process p, long clock) {
    	cpuQueue.add(p);
    	updateMaxCpuTime();
    	p.enteredCpuQueue(clock);
    	if (activeProcess == null) {
    		return switchProcess(clock);    		
    	}
    	return null;
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event switchProcess(long clock) {
        if (!cpuQueue.isEmpty()) {
        	Process temp = activeProcess;
        	
        	if (temp != null) {
        		temp.leftCpu(clock);
        		cpuQueue.addLast(temp);
        		temp.enteredCpuQueue(clock);
        		
        	}
        	
        	activeProcess = cpuQueue.pollFirst();
        	activeProcess.enteredCpu(clock);
        	return findNextEvent(activeProcess, clock);
        }
        
        if (activeProcess != null) {
        	cpuQueue.addLast(activeProcess);
        	activeProcess.leftCpu(clock);
        	activeProcess.enteredCpuQueue(clock);
        	activeProcess = null;
        	return switchProcess(clock);
        }
        return null;
    }
    
    
    public Process endActiveProcess(long clock) {
    	
    	Process temp = activeProcess;
    	temp.leftCpu(clock);
    	activeProcess = null;
    	return temp;
    }

    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     * @return	The event generated by the process switch, or null if no new
     *			process was switched in.
     */
    public Event activeProcessLeft(long clock) {
        // Incomplete
    	activeProcess.leftCpu(clock);
    	activeProcess = null;
    	
    	return switchProcess(clock);
    }

    /**
     * Returns the process currently using the CPU.
     * @return	The process currently using the CPU.
     */
    public Process getActiveProcess() {
        // Incomplete
        return activeProcess;
    }

    /**
     * This method is called when a discrete amount of time has passed.
     * @param timePassed	The amount of time that has passed since the last call to this method.
     */
    public void timePassed(long timePassed) {
    	statistics.cpuQueueLengthTime += cpuQueue.size()*timePassed;
    	statistics.cpuQueueLargestLength = (statistics.cpuQueueLargestLength < cpuQueue.size()) 
    			? cpuQueue.size() : statistics.cpuQueueLargestLength;
    	
    	
        // Incomplete
    }

}
